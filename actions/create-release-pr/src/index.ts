import * as core from '@actions/core';
import * as github from '@actions/github';
import { discoverProjects } from '@cpdevtools/ts-dev-utilities/project';
import { parseJson } from '@cpdevtools/ts-dev-utilities/json';
import { resolveVersion } from '@cpdevtools/git-flow/version';
import { readFile } from 'node:fs/promises';

interface VersionsConfig {
  [placeholder: string]: string;
}

interface ProjectMetadata {
  name: string;
  version: string;
  resolvedVersion: string;
  isPreRelease: boolean;
}

async function run() {
  try {
    // Get inputs
    const branch = core.getInput('branch', { required: true });
    const token = core.getInput('token', { required: true });
    const versionsFile = core.getInput('versions-file') || '.github/versions.json';
    const runNumber = parseInt(core.getInput('run-number') || '0', 10);

    core.info(`Creating release PR for branch: ${branch}`);
    core.info(`Run number: ${runNumber}`);

    // Load versions configuration
    const versionsContent = await readFile(versionsFile, 'utf-8');
    const versionsByPlaceholder = parseJson(versionsContent) as VersionsConfig;
    core.info(`Loaded versions: ${JSON.stringify(versionsByPlaceholder)}`);

    // Discover projects in workspace
    const projects = await discoverProjects({
      cwd: process.cwd(),
      patterns: ['**/package.json', 'packages/*/package.json'],
    });
    core.info(`Found ${projects.length} projects`);

    // Resolve versions for each project
    const projectMetadata: ProjectMetadata[] = [];
    
    for (const project of projects) {
      const packageVersion = project.packageJson.version;
      if (!packageVersion) {
        core.warning(`Skipping ${project.packageJson.name}: no version in package.json`);
        continue;
      }

      try {
        const result = await resolveVersion({
          placeholder: packageVersion,
          branch,
          versionsByPlaceholder,
          runNumber,
        });

        projectMetadata.push({
          name: project.packageJson.name || 'unknown',
          version: packageVersion,
          resolvedVersion: result.version,
          isPreRelease: result.isPreRelease,
        });

        core.info(
          `${project.packageJson.name}: ${packageVersion} → ${result.version} (pre-release: ${result.isPreRelease})`,
        );
      } catch (error) {
        core.warning(
          `Failed to resolve version for ${project.packageJson.name}: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    }

    // Create release branch name
    const releaseBranch = `release/${branch}`;
    core.info(`Release branch: ${releaseBranch}`);

    // Initialize GitHub client
    const octokit = github.getOctokit(token);
    const { owner, repo } = github.context.repo;

    // Get current commit SHA
    const { data: refData } = await octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${branch}`,
    });
    const sha = refData.object.sha;
    core.info(`Current SHA: ${sha}`);

    // Create or update release branch
    try {
      await octokit.rest.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${releaseBranch}`,
        sha,
      });
      core.info(`Created release branch: ${releaseBranch}`);
    } catch (error: any) {
      if (error.status === 422) {
        // Branch already exists, update it
        await octokit.rest.git.updateRef({
          owner,
          repo,
          ref: `heads/${releaseBranch}`,
          sha,
          force: true,
        });
        core.info(`Updated existing release branch: ${releaseBranch}`);
      } else {
        throw error;
      }
    }

    // Generate PR body with metadata
    const metadata = {
      branch,
      runNumber,
      sha,
      projects: projectMetadata,
      generatedAt: new Date().toISOString(),
    };

    const prBody = `## Release from \`${branch}\`

### Metadata

\`\`\`yaml
${generateYamlMetadata(metadata)}
\`\`\`

### Projects

${projectMetadata.map((p) => `- **${p.name}**: \`${p.version}\` → \`${p.resolvedVersion}\``).join('\n')}

---
*Generated by create-release-pr action*
`;

    // Check if PR already exists
    const { data: existingPRs } = await octokit.rest.pulls.list({
      owner,
      repo,
      head: `${owner}:${releaseBranch}`,
      base: branch,
      state: 'open',
    });

    // Check if branches have differences
    const { data: comparison } = await octokit.rest.repos.compareCommitsWithBasehead({
      owner,
      repo,
      basehead: `${branch}...${releaseBranch}`,
    });

    const hasDifferences = comparison.ahead_by > 0 || comparison.behind_by > 0;

    if (!hasDifferences) {
      core.info('No differences between branches');
      
      // Close any existing PR since there are no changes
      if (existingPRs.length > 0) {
        const pr = existingPRs[0];
        await octokit.rest.pulls.update({
          owner,
          repo,
          pull_number: pr.number,
          state: 'closed',
        });
        core.info(`Closed PR #${pr.number} (no differences)`);
      }
      
      core.info('✅ No PR needed - branches are identical');
      core.setOutput('pr-number', '');
      core.setOutput('pr-url', '');
      core.setOutput('release-branch', releaseBranch);
      return;
    }

    let prNumber: number;
    let prUrl: string;

    if (existingPRs.length > 0) {
      // Update existing PR
      const pr = existingPRs[0];
      const { data: updatedPR } = await octokit.rest.pulls.update({
        owner,
        repo,
        pull_number: pr.number,
        body: prBody,
      });
      prNumber = updatedPR.number;
      prUrl = updatedPR.html_url;
      core.info(`Updated existing PR #${prNumber}`);
    } else {
      // Create new PR
      const { data: newPR } = await octokit.rest.pulls.create({
        owner,
        repo,
        title: `Release from ${branch}`,
        head: releaseBranch,
        base: branch,
        body: prBody,
        draft: true,
      });
      prNumber = newPR.number;
      prUrl = newPR.html_url;
      core.info(`Created new PR #${prNumber}`);
    }

    // Set outputs
    core.setOutput('pr-number', prNumber);
    core.setOutput('pr-url', prUrl);
    core.setOutput('release-branch', releaseBranch);

    core.info(`✅ Success! PR: ${prUrl}`);
  } catch (error) {
    core.setFailed(`Action failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}

function generateYamlMetadata(metadata: any): string {
  const yaml = [
    `branch: ${metadata.branch}`,
    `runNumber: ${metadata.runNumber}`,
    `sha: ${metadata.sha}`,
    `generatedAt: ${metadata.generatedAt}`,
    'projects:',
  ];

  for (const project of metadata.projects) {
    yaml.push(`  - name: ${project.name}`);
    yaml.push(`    version: ${project.version}`);
    yaml.push(`    resolvedVersion: ${project.resolvedVersion}`);
    yaml.push(`    isPreRelease: ${project.isPreRelease}`);
  }

  return yaml.join('\n');
}

run();
